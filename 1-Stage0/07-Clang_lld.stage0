# cgnutools: Stage0 Clang+lld+llvm-base 
# Build as cmlfs
#
# o Reuse llvm-project source tree from before
# o stage 0 Clang will depend on cross-gcc headers & libraries. 
#   It will build stage1 w/o libgcc_s & cross-gcc
# o stage 0 clang will be used to build the stage 1 compiler-rt, 
#   libc++, linunwind before stag1 clang+lld+llvm-base

# Force clang to use dynamic linux loader in /llvmtools
patch -Np1 -i ../patches/llvm-cmlfs/modify-toolchain-dynamic-loader.llvmtools.patch 
patch -Np1 -i ../patches/llvm-cmlfs/modify-test-dynamic-loader.llvmtools.patch 

# Set rpath as host's GCC will be used
export  CFLAGS="-fPIC -Wl,-rpath=/opt/gnu/lib "
export CXXFLAGS=$CFLAGS

# Set cmake options
export EPRJS="clang;lld"
export  CARG="-DCMAKE_BUILD_TYPE=Release "
export CARG+="-DCMAKE_INSTALL_PREFIX=/cgnutools "
export CARG+="-DLLVM_HOST_TRIPLE=${CMLFS_HOST} "
export CARG+="-DLLVM_TARGET_ARCH=${LARCH} "
export CARG+="-DLLVM_TARGETS_TO_BUILD=host;${LARCH} "
export CARG+="-DLLVM_ENABLE_EH=ON -DLLVM_ENABLE_RTTI=ON "
export CARG+="-DLLVM_INCLUDE_TESTS=OFF "
export CARG+="-DLIBCLANG_BUILD_STATIC=ON "
export CARG+="-DLLVM_ENABLE_PROJECTS=${EPRJS} "
export CARG+="-DLLVM_DEFAULT_TARGET_TRIPLE=${TARGET_TUPLE} "
export CARG+="-DLLVM_TABLEGEN=/cgnutools/${CMLFS_HOST}/bin/llvm-tblgen "
export CARG+="-DCLANG_TABLEGEN=/cgnutools/${CMLFS_HOST}/bin/clang-tblgen "

# Configure source
PATH=/opt/gnu/bin:/bin CC=gcc CXX=g++ \
cmake -B build0 -G Ninja -Wno-dev -S llvm $CARG -DCLANG_VENDOR="cgnutools 4.0.1"

# Compile
PATH=/opt/gnu/bin:/bin ninja -C build0

# Install
cmake --install build0 --strip 

# Install llvm-lit iscript for buidling standalone LLVM projects
cp -va build0/bin/llvm-lit /cgnutools/bin/

# Make lld the default linker
ln -sv ld.lld /cgnutools/bin/ld

# Create a link for libatomics for stage0 clang to use
ln -sv /llvmtools/lib/libatomic.so.1.69.0 /cgnutools/lib/libatomic.so

# Configure stage 0 clang
cat > /cgnutools/bin/${TARGET_TUPLE}.cfg <<EOF 
-fuse-ld=lld
--sysroot=/cgnutools 
EOF

# Test stage0 Clang
cd $CMLFS/sources
echo "int main(){}" > dummy.c
/cgnutools/bin/clang dummy.c -v -Wl,--verbose &> dummy.log
readelf -l a.out | grep ': /llvmtools'

# Should output like:
# Requesting program interpreter: /llvmtools/lib/ld-musl-aarch64.so.1

# Check if the correct start files are used
grep  'crt[1in].o' dummy.log | grep 'ld.lld: '
# Should output:
# ld.lld: /cgnutools/lib/Scrt1.o
# ld.lld: /cgnutools/lib/crti.o
# ld.lld: /cgnutools/lib/crtn.o

# Verify that stage0 clang is searching for the correct header files:
grep -B0 -A4 'search starts here' dummy.log
# #include "..." search starts here:
# #include <...> search starts here:
#  /cgnutools/lib/gcc/aarch64-pc-linux-musl/13.2.0/../../../../aarch64-pc-linux-musl/include
#  /cgnutools/usr/include
#  /mnt//cmlfs/cgnutools/lib/clang/17/include
# NOTE: Above will differ sligthly if compiling for a different arch

# Check if stage0 clang++ [in llvmtools] has atomics.
cat > atomics-test.cpp << "EOF"
#include <atomic>
std::atomic<int> x;
std::atomic<short> y;
std::atomic<char> z;
int main() {
  ++z;
  ++y;
  return ++x;
}
EOF

/cgnutools/bin/clang++ \
atomics-test.cpp -v -Wl,--verbose &> atomics-test.log

# Check for errors during compile or link:
grep error:  atomics-test.log
# Should return nothing if there are no errors.

# Verify that stage0 clang is searching for the correct C++ header files:
grep -B0 -A7 'search starts here'  atomics-test.log
# Should output:
# #include "..." search starts here:
# #include <...> search starts here:
#  /cgnutools/lib/gcc/aarch64-pc-linux-musl/13.2.0/../../../../aarch64-pc-linux-musl/include/c++/13.2.0
#  /cgnutools/lib/gcc/aarch64-pc-linux-musl/13.2.0/../../../../aarch64-pc-linux-musl/include/c++/13.2.0/aarch64-pc-linux-musl
#  /cgnutools/lib/gcc/aarch64-pc-linux-musl/13.2.0/../../../../aarch64-pc-linux-musl/include/c++/13.2.0/backward
#  /cgnutools/lib/gcc/aarch64-pc-linux-musl/13.2.0/../../../../aarch64-pc-linux-musl/include
#  /cgnutools/usr/include
#  /mnt/cmlfs/cgnutools/lib/clang/17/include
# End of search list.
# NOTE: Above will differ sligthly if compiling for a different arch
# NOTE: the c++ directory should be searched before /cgnutools/usr/include

# Check if stage 0 clang supports exception handling:
/cgnutools/bin/clang++ files/eh-test.cpp -v -Wl,--verbose &> eh-test.log
grep error: eh-test.log
# Should return nothing (this means no compilation errors)

# Stage 0 Clang is now configured & tested to use libgcc (not compiler-rt) and libstdcxx (not libc++)  

# If all is good, remove build directory. Source tree will be re-used later
rm -rf build dummy.* atomics-test.* cxx11-test.* eh-test.log
unset CT CTG CP CRT CLG CLCPP CLCPPA CUW CLLVM COFF CFLAGS CXXFLAGS LINKERFLAGS

# Final System - Adjust Tool Chain
# This section is done in Chroot environment

# Create configuration for stage1 clang:
touch /llvmtools/bin/${TUPLE}.cfg

# Re-configure stage1 clang to use new sysroot (/usr) with newly built musl Libc
echo "--sysroot=/usr " > /llvmtools/bin/${TUPLE}.cfg

# Create a link of clang to use configuration:
ln -sv clang-15 /llvmtools/bin/${TUPLE}-clang
ln -sv clang-15 /llvmtools/bin/${TUPLE}-clang++

# For creating static binaries & libraries, create links for
# missing object files
#ln -sv clang_rt.crtbegin.o /llvmtools/lib/clang/15.0.5/x86_64-pc-linux-musl/crtbeginT.o
#ln -sv clang_rt.crtend.o   /llvmtools/lib/clang/15.0.5/x86_64-pc-linux-musl/crtend.o

# Prevent stage1 clang from using GCC.
# If GCC is needed, just revert the change.
mv -v /llvmtools/lib/gcc /llvmtools/lib/gcc-BLOCKED

# Adjust binutils linker of llvmtools:
mv -v  /llvmtools/bin/{ld.bfd,ld.bfd-old}
mv -v  /llvmtools/x86_64-pc-linux-musl/bin/{ld.bfd,ld-old}
mv -v  /llvmtools/bin/{ld.bfd-new,ld.bfd}
rm -v /llvmtools/x86_64-pc-linux-musl/bin/ld
ln -sv /llvmtools/bin/ld.bfd /llvmtools/x86_64-pc-linux-musl/bin/ld

# Make sure the  build environment has the default compilers set
export  CC=${TUPLE}-clang
export CXX=${TUPLE}-clang++

# Test stage 1 clang
echo "int main(){}" > dummy.c
${CC} dummy.c -v -Wl,--verbose &> dummy.log
patchelf --set-interpreter /lib/ld-musl-x86_64.so.1 a.out
readelf -l a.out | grep ': /lib'

# Should output:
# [Requesting program interpreter: /lib/ld-musl-x86_64.so.1]

# Check if the correct start files are used
grep  'crt[1in]' dummy.log | grep ld.lld:

# Should output:
# ld.lld: /usr/lib/Scrt1.o
# ld.lld: /usr/lib/crti.o
# ld.lld: /usr/lib/crtn.o

# Check if stage1 clang++ has atomics. Usually atomics are provided by gcc,
# therefore, stage 1 clang++ should not depend on gcc. Building the native
# final clang (stage 2) requires stage 1 clang++ to support std::atomic
cat > atomics-test.cpp << "EOF"
#include <atomic>
std::atomic<int> x;
std::atomic<short> y;
std::atomic<char> z;
int main() {
  ++z;
    ++y;
      return ++x;
      }
EOF

${CXX} atomics-test.cpp  -v -Wl,--verbose &> atomics-test.log

# Check for errors during compile or link:
grep error:  atomics-test.log

# Should return nothing if there are no errors.

# Test if stage1 clang still supports C++11
cat > cxx11-test.cpp << "EOF"
#include <iostream>

int main(){
   #if __cplusplus==201402L
   std::cout << "C++14" << std::endl;
   #elif __cplusplus==201103L
   std::cout << "C++11" << std::endl;
   #else
   std::cout << "C++" << std::endl;
   #endif

   return 0;
}
EOF

${CXX} cxx11-test.cpp -v -Wl,--verbose &> cxx11-test.log

# Check for errors during compile or link:
grep error: cxx11-test.log

# Once everything is working correctly, clean up
# the test files:
rm -v dummy.c a.out dummy.log atomics-test.cpp atomics-test.log cxx11-test.cpp cxx11-test.log

# General Build Notes for cgnutools

# Builds for cgnutools assume the following:
# o bash is the shell in use
# o sh is a symbolic link to bash
# o /usr/bin/awk is a symbolic link to gawk
# o /usr/bin/yacc is a symbolic link to bison
#   or a script that executes bison
# o flex is required when building source snapshots of GCC

echo $SHELL
file /bin/sh
file /usr/bin/awk
file /usr/bin/yacc
which flex

# Make sure building cgnutools as cmlfs
whoami

# Make sure PATH is set correctly:
export PATH=/cgnutools/bin:/llvmtools/bin:/usr/bin:/bin

# Each package should be unpacked in /mnt/cmlfs/source and change
# to the unpacked source directory. For example:
cd /mnt/cmlfs/sources
tar xf pkgs/foo-1.2.3.tar.gz
cd foo-1.2.3

# Then patch and compile per instruction
patch -Np1 -i ../patches/foo-mlfs/fix-it.patch
./configure --prefix=/cgnutools
make
make install

# After the package is installed, change directories and remove
# unpacked source directory unless instructed:
cd ..
rm -rf foo-1.2.3

# Extra notes:
# Most compilers provide a way to disable the
# default behavior for finding the standard
# library and to override it with custom paths.
# With Clang, this can be done with:

clang++ -nostdinc++ -nostdlib++           \
        -isystem <install>/include/c++/v1 \
        -L <install>/lib                  \
        -Wl,-rpath,<install>/lib          \
        -lc++                             \
        test.cpp

# Cross GCC (mussel)
# Bin directory: /cgnutools/bin/${TARGET_TUPLE}-*
# Header search paths:
#  o /cgnutools/bin/../lib/gcc/x86_64-pc-linux-musl/12.2.0/../../../../x86_64-pc-linux-musl/include
#  o /cgnutools/lib/gcc/x86_64-pc-linux-musl/12.2.0/include
#  o /cgnutools/usr/include
#  Library search paths:
#  o /cgnutools/x86_64-pc-linux-musl/lib64
#  o /usr/local/lib64
#  o /lib64
#  o /usr/lib64
#  o /cgnutools/x86_64-pc-linux-musl/lib
#  o /usr/local/lib
#  Sysroot = /cgnutools

# Cross-gcc will stay in cgnutools, but cross-compile a clang toolchain in llvmtools. It will
# also build the required packages [in llvmtools] to build stage0 clang
# o kernel headers
# o musl libc
# o zlib-ng
# X netbsd-curses (optional)
# X libexecinfo -- patch from chimera removed dependancy
# o libatomic-chimera
# o fortify-headers
# o CMake (if host doesn't have it?)
# o Python3 (if host doesn't have it?)

# Stage0 clang will compile the following for llvmtools:
# o openssl [optional?]
# o git ?
# o bubblewrap ?
# o chimerautils ?
# o elftoolchain
# o libedit
# o libffi ?
# o pkgconf ?
# o byacc
# o flex
# o perl
# o cmake
# o meson
# o bmake/gmake
# o ninja

# To-Do:
# o Do not install fortify-headers. Byacc will not compile:
clang  -g -O2 -Qunused-arguments -Wno-error=implicit-function-declaration -I. -I.  -DHAVE_CONFIG_H -DYYPATCH=`cat ./VERSION`   -o yacc closure.o error.
o graph.o lalr.o lr0.o main.o mkpar.o mstring.o output.o reader.o btyaccpar.o symtab.o verbose.o warshall.o
ld.lld: error: undefined symbol: __builtin_va_arg_pack
>>> referenced by stdio.h:0 (/llvmtools/usr/include/fortify/stdio.h:0)
>>>               main.o:(open_tmpfile)
>>> referenced by stdio.h:0 (/llvmtools/usr/include/fortify/stdio.h:0)
>>>               output.o:(output)
>>> referenced by reader.c:0 (/mnt/cmlfs/sources/byacc-20221229/reader.c:0)
>>>               reader.o:(reader)
>>> referenced 2 more times
clang-15: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [makefile:129: yacc] Error 1
